\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{physics}
\usepackage{mathtools}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{xcolor}

\newcommand{\bR}{\mathbf{R}}
\newcommand{\id}{\mathbb{I}}
\newcommand{\Tr}{\mathrm{Tr}}

\title{Irrep-Resolved Filter Functions for Qudit QSP:\\Analytic Plan and Code Strategy}
\author{filterQSP development}
\date{February 2026}

\begin{document}
\maketitle

%=============================================================================
\section{Overview and Goals}
%=============================================================================

We extend the filter function formalism from qubits (Section 3 of QSP Clock Draft) and three-level clocks (Section 4) to arbitrary $d$-level qudit systems. The key new ingredients are:

\begin{enumerate}
    \item \textbf{Spin-displacement pulses} as the signal processing operators (Section 5.2 of draft), replacing SU(2) rotations.
    \item \textbf{Irrep decomposition} of the noise response in the adjoint (Liouville) space, generalizing the Bloch vector components $(R_x, R_y, R_z)$ to $d^2-1$ generalized Gell-Mann (GGM) components grouped by irreps of SU($d$).
    \item \textbf{Application to Grover's algorithm}: analyzing the fidelity filter function of $d$-pulse diffusion operator sequences under $J_z$ dephasing noise.
\end{enumerate}

%=============================================================================
\section{Mathematical Framework}
%=============================================================================

\subsection{Spin-Displacement Pulses}

From Section 5.2 of the draft, a spin-displacement pulse is generated by the multi-tone rotating-frame Hamiltonian:
\begin{equation}
    H_{\mathrm{rot}}(\vec\varphi) = \sum_{k=0}^{d-2} \Omega_k \left(e^{i\varphi_k}\ket{k}\bra{k+1} + e^{-i\varphi_k}\ket{k+1}\bra{k}\right) + \sum_{k=0}^{d-2}\delta_k \ket{k+1}\bra{k+1}
    \label{eq:H_rot}
\end{equation}
where $\Omega_{k} = \Omega\sqrt{(k+1)(d-k-1)}$ produces $H_{\mathrm{rot}}(\vec\varphi=\vec 0) = \Omega J_x$ (the spin-$j$ $x$-operator with $j=(d-1)/2$). The spin-displacement pulse unitary is:
\begin{equation}
    D(\vec\varphi, \theta) = e^{-i\theta H_{\mathrm{rot}}(\vec\varphi)/\Omega}
\end{equation}
A general $d$-length pulse sequence approximating a target unitary $U$ is:
\begin{equation}
    U \approx \prod_{n=1}^d D(\vec\varphi_n, \theta_n) = S(\vec\varphi_0)\prod_{n=1}^d D(\theta_n)S(\vec\varphi_n)
    \label{eq:pulse_seq}
\end{equation}
where $S(\vec\varphi)$ are virtual SNAP gates (diagonal phase gates) and $D(\theta) = D(\vec 0, \theta)$.

\subsection{Noise Model}

We consider diagonal dephasing noise analogous to the qubit case:
\begin{equation}
    H_\epsilon(t) = \beta(t) J_z = \beta(t)\sum_{m=-j}^{j} m\ket{m}\bra{m}
    \label{eq:noise}
\end{equation}
where $\beta(t)$ is a zero-mean stationary Gaussian process with PSD $S_\beta(\omega)$. This is the natural generalization of $\beta(t)\sigma_z/2$ for qubits. For atomic systems, this corresponds to magnetic field noise coupling through the Zeeman interaction, where different $m$-levels have different sensitivities proportional to $m$.

\textcolor{blue}{Extension: For more general noise models (e.g., independent noise on each level, quadrupolar noise), we can write $H_\epsilon(t) = \sum_\alpha \beta_\alpha(t) N_\alpha$ where $N_\alpha$ are generators. The framework below applies to each noise channel.}

\subsection{Toggling Frame and Matrix Filter Function}

Following the existing framework, the toggling-frame noise Hamiltonian is:
\begin{equation}
    \tilde{H}(t) = U_{\mathrm{QSP}}^\dagger(t) H_\epsilon(t) U_{\mathrm{QSP}}(t) = \beta(t) \cdot U_{\mathrm{QSP}}^\dagger(t) J_z U_{\mathrm{QSP}}(t)
    \label{eq:toggling}
\end{equation}
where $U_{\mathrm{QSP}}(t)$ is the piecewise propagator built from spin-displacement pulses:
\begin{equation}
    U_{\mathrm{QSP}}(t) = \sum_{n=1}^d W_n(t) \, U_n(t) \, Q_{n-1}
\end{equation}
with $Q_{n-1} = D(\vec\varphi_{n-1},\theta_{n-1})\cdots D(\vec\varphi_1,\theta_1)$ and $U_n(t)$ the partial evolution during pulse $n$.

The \textbf{matrix-valued filter function} (already implemented in \texttt{fft\_filter\_function.py}) is:
\begin{equation}
    \tilde{H}(t) = \beta(t)\, h(t), \qquad \hat{h}(\omega) = \int_0^T h(t) e^{-i\omega t}\,dt
    \label{eq:matrix_ff}
\end{equation}
This $d\times d$ matrix $\hat{h}(\omega)$ fully characterizes the spectral filtering.

\subsection{Generalized Bloch (GGM) Decomposition}

For a $d$-level system, the traceless Hermitian operator $h(t)$ can be expanded in the generalized Gell-Mann (GGM) basis $\{\lambda_a\}_{a=1}^{d^2-1}$:
\begin{equation}
    h(t) = \sum_{a=1}^{d^2-1} R_a(t)\,\lambda_a, \qquad R_a(t) = \frac{1}{2}\Tr[\lambda_a\, h(t)]
    \label{eq:ggm_decomp}
\end{equation}
where $\Tr(\lambda_a\lambda_b) = 2\delta_{ab}$. The GGM matrices organize into three types:
\begin{itemize}
    \item \textbf{Symmetric off-diagonal} ($d(d-1)/2$ matrices): $(\lambda^s_{jk})_{mn} = \delta_{mj}\delta_{nk} + \delta_{mk}\delta_{nj}$ for $j<k$
    \item \textbf{Antisymmetric off-diagonal} ($d(d-1)/2$ matrices): $(\lambda^a_{jk})_{mn} = -i(\delta_{mj}\delta_{nk} - \delta_{mk}\delta_{nj})$ for $j<k$
    \item \textbf{Diagonal} ($d-1$ matrices): $\lambda^d_l = \sqrt{\frac{2}{l(l+1)}}\left(\sum_{m=1}^l \ket{m}\bra{m} - l\ket{l+1}\bra{l+1}\right)$
\end{itemize}

The GGM components $R_a(t)$ are the qudit generalization of the Bloch vector $(R_x, R_y, R_z)$.

\subsection{Fidelity Filter Function via Magnus Expansion}

For the fidelity metric (Eq.~80 of draft):
\begin{equation}
    \mathcal{F}(T) = \frac{1}{d^2}\langle|\Tr[U_{\mathrm{QSP}}^\dagger(T) U(T)]|^2\rangle \approx 1 - \frac{1}{\hbar^2}\int\frac{d\omega}{2\pi} S_\beta(\omega) F_{\mathrm{fid}}(\omega)
\end{equation}
where the \textbf{fidelity filter function} is:
\begin{equation}
    \boxed{F_{\mathrm{fid}}(\omega) = \Tr[\hat{h}(\omega)\hat{h}^\dagger(\omega)] = \frac{1}{2}\sum_{a=1}^{d^2-1}|\hat{R}_a(\omega)|^2}
    \label{eq:fidelity_ff}
\end{equation}
This is exactly the \texttt{noise\_susceptibility\_from\_matrix} already in the code.

\subsection{Irrep Decomposition of the Adjoint Representation}

This is the key new theoretical contribution. Under the adjoint action of SU($d$), the space of traceless Hermitian $d\times d$ matrices decomposes into irreducible representations. For the noise $J_z$ (which generates a U(1) subgroup), the relevant decomposition depends on the control group.

\subsubsection{Approach 1: Transition-Based Decomposition}

The simplest and most physically transparent decomposition groups the GGM components by the \textbf{transition} $(j,k)$ they couple:

\begin{equation}
    h(t) = \sum_{j<k} \left[R^s_{jk}(t)\lambda^s_{jk} + R^a_{jk}(t)\lambda^a_{jk}\right] + \sum_{l=1}^{d-1} R^d_l(t)\lambda^d_l
\end{equation}

Under $J_z$ dephasing, noise on different transitions $(j,k)$ picks up different phase factors $e^{i(m_j-m_k)\omega t}$ from the Zeeman splitting. The filter function decomposes as:
\begin{equation}
    F_{\mathrm{fid}}(\omega) = \sum_{j<k} F_{jk}(\omega) + F_{\mathrm{diag}}(\omega)
    \label{eq:transition_decomp}
\end{equation}
where
\begin{equation}
    F_{jk}(\omega) = |\hat{R}^s_{jk}(\omega)|^2 + |\hat{R}^a_{jk}(\omega)|^2
\end{equation}
couples transitions with $\Delta m = m_j - m_k$.

\subsubsection{Approach 2: SU($d$) Adjoint Irrep Decomposition}

Following Blume-Kohout's ``Synthetic Quantum Circuits'' framework, the Liouville space decomposes as:
\begin{equation}
    \mathbf{d}\otimes\mathbf{d}^* = \mathbf{1} \oplus \mathbf{(d^2-1)}
\end{equation}
For the full SU($d$) adjoint, the $\mathbf{d^2-1}$ representation is irreducible. However, when the control group $G$ is a \textit{subgroup} of SU($d$) (e.g., the group generated by spin-displacement pulses), the adjoint representation may decompose further:
\begin{equation}
    \mathbf{d^2-1}\Big|_G = \bigoplus_\lambda m_\lambda \mathbf{d_\lambda}
\end{equation}
with projectors $P_\lambda$ onto each irrep sector.

The \textbf{irrep-resolved filter function} is then:
\begin{equation}
    \boxed{F_\lambda(\omega) = \Tr\left[P_\lambda \hat{h}(\omega) P_\lambda \hat{h}^\dagger(\omega)\right]}
    \label{eq:irrep_ff}
\end{equation}
satisfying $F_{\mathrm{fid}}(\omega) = \sum_\lambda F_\lambda(\omega)$.

\textcolor{blue}{For $d=2$ (qubit): the adjoint is the spin-1 (triplet) irrep, and $P_\lambda$ trivially projects onto the full space. The three GGM components are the Pauli components $(R_x, R_y, R_z)$. \\
For $d=3$ (qutrit with SU(3)): $\mathbf{3}\otimes\mathbf{3}^* = \mathbf{1}\oplus\mathbf{8}$, and the 8-dimensional adjoint is irreducible under full SU(3). Subgroup decompositions (e.g., SU(2)$\subset$SU(3)) can further split $\mathbf{8} = \mathbf{3}\oplus\mathbf{2}\oplus\mathbf{2}\oplus\mathbf{1}$.}

\subsubsection{Approach 3: Angular Momentum Irrep Decomposition (for $J_z$ noise)}

For $J_z$ noise specifically, the most natural irrep decomposition uses the angular momentum coupling:
\begin{equation}
    j \otimes j = 0 \oplus 1 \oplus 2 \oplus \cdots \oplus 2j
\end{equation}
where $j = (d-1)/2$. The noise operator $J_z$ lives in the $L=1$ (vector) sector. Under the control group generated by spin-displacement pulses (which generate the full SU(2) spin-$j$ representation), each $L$-sector has a definite irrep filter function:
\begin{equation}
    F_L(\omega) = \sum_{M=-L}^{L} |C_{LM}(\omega)|^2
\end{equation}
where $C_{LM}(\omega)$ are the spherical tensor components of $\hat{h}(\omega)$ in the irrep-$L$ sector.

This connects directly to Blume-Kohout: the decoherence function for irrep $L$ is:
\begin{equation}
    \chi_L(T) = \frac{1}{2\pi}\int d\omega\, S_\beta(\omega)\, F_L(\omega)
\end{equation}

\textcolor{blue}{Key insight: For pure $J_z$ noise (rank 1 tensor), to first order only $L=1$ contributes. Higher-order Magnus terms can populate $L=2,3,\ldots$ via products of $J_z$ operators. The filter function decomposition by $L$ tells us which angular momentum channels are corrupted at each frequency.}

%=============================================================================
\section{Recursive Structure for Spin-Displacement Sequences}
%=============================================================================

For a sequence of $d$ spin-displacement pulses $D(\vec\varphi_n, \theta_n)$, we need a recursion analogous to the qubit $(f_j, g_j)$ polynomials.

\subsection{Qudit ``Polynomial'' Recursion}

Define $Q_n = D(\vec\varphi_n,\theta_n)\cdots D(\vec\varphi_1,\theta_1)$ as the cumulative unitary after $n$ pulses. The matrix elements:
\begin{equation}
    (Q_n)_{mk} = \bra{m}Q_n\ket{k}
\end{equation}
satisfy the recursion:
\begin{equation}
    (Q_n)_{mk} = \sum_{l=0}^{d-1} \bra{m}D(\vec\varphi_n,\theta_n)\ket{l}(Q_{n-1})_{lk}
\end{equation}
with $Q_0 = \id$. For each pulse, the matrix elements of $D(\vec\varphi_n,\theta_n)$ can be computed using the spin-$j$ rotation matrices (Wigner $d$-functions) with SNAP phase modifications:
\begin{equation}
    D(\vec\varphi,\theta) = S(\vec\varphi)\, e^{-i\theta J_x}\, S(-\vec\varphi) \cdot S(\vec\varphi)
\end{equation}

\textcolor{blue}{In practice, for numerical implementation, we simply exponentiate $H_{\mathrm{rot}}$ from Eq.~\eqref{eq:H_rot}. The recursion is used analytically to understand the polynomial structure.}

\subsection{Time-Dependent Propagator}

During the $n$-th pulse, if we are at time $t$ with $t_{n-1} \le t < t_n$:
\begin{equation}
    U_{\mathrm{QSP}}(t) = e^{-i H_{\mathrm{rot}}^{(n)}(t-t_{n-1})/\Omega_n} \cdot Q_{n-1}
\end{equation}
This is the qudit generalization of Eq.~(32-33) in the draft. The toggling-frame operator becomes:
\begin{equation}
    h(t) = Q_{n-1}^\dagger\, e^{+iH_{\mathrm{rot}}^{(n)}(t-t_{n-1})/\Omega_n}\, J_z\, e^{-iH_{\mathrm{rot}}^{(n)}(t-t_{n-1})/\Omega_n}\, Q_{n-1}
\end{equation}

%=============================================================================
\section{Application: Grover Diffusion Operator}
%=============================================================================

The qudit Grover diffusion operator for a $d$-level system is a $d$-length spin-displacement pulse sequence:
\begin{equation}
    U_{\mathrm{Grover}} = \prod_{n=1}^d D(\vec\varphi_n, \theta_n)
\end{equation}
where the phases $\{\vec\varphi_n, \theta_n\}$ are found via gradient descent in the MQS Prog suite.

\subsection{What We Want to Compute}

For a given Grover pulse sequence:
\begin{enumerate}
    \item \textbf{Total fidelity filter function} $F_{\mathrm{fid}}(\omega)$: How much noise at frequency $\omega$ degrades the gate fidelity.
    \item \textbf{GGM-component filter functions} $|\hat{R}_a(\omega)|^2$: Which generalized Bloch components are most sensitive to noise at each frequency.
    \item \textbf{Irrep-resolved filter functions} $F_L(\omega)$: Which angular momentum sectors of the Liouville space are corrupted, and at what frequencies.
    \item \textbf{Comparison across sequences}: Different pulse sequences $\{\vec\varphi_n, \theta_n\}$ that all implement the same Grover diffusion but have different filter function profiles.
\end{enumerate}

\subsection{Noise Integration}

Given the filter functions and a noise PSD $S_\beta(\omega)$:
\begin{equation}
    1 - \mathcal{F} = \frac{1}{2\pi}\int d\omega\, S_\beta(\omega)\, F_{\mathrm{fid}}(\omega)
\end{equation}
For a comparison of $N$ different Grover sequences under the same noise, we compute $\{F_{\mathrm{fid}}^{(i)}(\omega)\}_{i=1}^N$ and rank by total infidelity under various PSDs (white, $1/f$, $1/f^2$, Lorentzian).

%=============================================================================
\section{Validation Strategy: FFT as Ground Truth}
%=============================================================================

The existing \texttt{fft\_filter\_function.py} provides a model-independent numerical computation of the matrix filter function for \textit{any} dimension $d$. It works by:
\begin{enumerate}
    \item Sampling $h(t) = U^\dagger(t) J_z U(t)$ on a fine time grid.
    \item Taking the FFT to get $\hat{h}(\omega)$.
    \item Computing $F_{\mathrm{fid}}(\omega) = \Tr[\hat{h}(\omega)\hat{h}^\dagger(\omega)]$.
\end{enumerate}

This serves as \textbf{ground truth} for all analytic formulas. The test pattern mirrors the existing qubit tests:

\begin{center}
\begin{tabular}{lll}
\textbf{Test} & \textbf{Analytic} & \textbf{FFT Reference} \\
\hline
Qudit Ramsey ($D(\theta)$ only) & $4\sin^2(\omega T/2)/\omega^2 \times \|J_z\|^2$ & FFT \\
Qudit CPMG ($D(\pi)$ pulses) & Switching function with $J_z$ & FFT \\
3-level Fe, Ff functions & Eqs (75-79) of draft & FFT projected \\
$d$-level GGM components & Eq.~\eqref{eq:ggm_decomp} decomposition & FFT + GGM projection \\
$d$-level irrep components & Eq.~\eqref{eq:irrep_ff} projection & FFT + irrep projectors \\
Grover diffusion ($d$ pulses) & Recursive formula & FFT \\
\end{tabular}
\end{center}

%=============================================================================
\section{Assessment of Qudit Irrep FF Document}
%=============================================================================

The ChatGPT-generated ``Qudit\_Irrep\_FF'' document has several \textbf{correct} elements and some \textbf{issues}:

\textbf{Correct:}
\begin{itemize}
    \item The general structure of irrep-resolved Kubo variance with projected kernels $\mathcal{K}_\lambda(t,t')$ is sound (their Eq.~for $F_\lambda(\omega)$).
    \item The SU(3) adjoint decomposition $\mathbf{3}\otimes\mathbf{3}^* = \mathbf{1}\oplus\mathbf{8}$ is correct.
    \item The Gell-Mann basis expansion and commutation via structure constants $f_{abc}$ is standard.
    \item The adjoint rotation matrix $R_{ab}(t) = \frac{1}{2}\Tr(\lambda_a U^\dagger \lambda_b U)$ is correct.
\end{itemize}

\textbf{Issues:}
\begin{itemize}
    \item The qutrit example uses a ``computational vs leakage'' decomposition ($\{|0\rangle,|1\rangle\}$ vs $\{|2\rangle\}$) which is for RB-style benchmarking, \textbf{not} the spin-displacement / angular momentum setting we care about. In our case, all $d$ levels participate equally through $J_x$ rotations.
    \item The ``irrep-resolved filter function'' $F_a(\omega)$ indexed by noise channel $a$ (their Eq.~in Section on SU(3)) conflates noise channel index with irrep index. The proper irrep decomposition is in the \textit{Liouville space of the response}, not in the noise Hamiltonian basis.
    \item The connection to synthetic circuit twirling averages over random group elements, which is appropriate for RB but not for our deterministic QSP pulse sequences. We want the filter function of a \textit{specific} sequence, not the group average.
    \item Missing: the specific recursion structure for spin-displacement pulses and how it connects to the QSP polynomial formalism.
\end{itemize}

\textbf{Our approach corrects these issues} by:
\begin{enumerate}
    \item Using the spin-$j$ angular momentum coupling for irrep decomposition (natural for $J_z$ noise).
    \item Computing filter functions for specific deterministic pulse sequences (not twirl-averaged).
    \item Building on the existing QSP polynomial recursion structure extended to $d$ dimensions.
\end{enumerate}

%=============================================================================
\section{Summary of Deliverables}
%=============================================================================

\begin{enumerate}
    \item \textbf{Code: Spin-displacement pulse module} --- Implement $H_{\mathrm{rot}}(\vec\varphi)$, $D(\vec\varphi, \theta)$, and $d$-pulse sequences as \texttt{MultiLevelPulseSequence} objects compatible with existing FFT infrastructure.
    \item \textbf{Code: GGM basis and irrep projectors} --- Implement generalized Gell-Mann matrices, angular momentum coupling coefficients, and irrep projection operators $P_L$.
    \item \textbf{Code: Irrep-resolved filter functions} --- Extend \texttt{bloch\_components\_from\_matrix} to decompose by irrep sector.
    \item \textbf{Code: MQS Prog interface} --- Import pulse sequence parameters $\{\vec\varphi_n, \theta_n\}$ from the PyTorch optimization suite.
    \item \textbf{Tests: FFT validation} --- Qudit Ramsey, CPMG, and Grover sequences validated against FFT ground truth.
    \item \textbf{Analysis: Grover noise comparison} --- Compare filter functions of different Grover diffusion operator sequences.
\end{enumerate}

\end{document}
